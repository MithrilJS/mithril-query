'use strict';

var cssauron = require('cssauron');
var code = require('yields-keycode');
var m = require('mithril');

var filedata = require('fs').readFileSync('./mithril-mock.js','utf8');
var mockWindow = eval(filedata);

var PD = '//';

function identity(thing) {
  return thing;
}

function isString(thing) {
  return typeof thing === 'string';
}

function isNumber(thing) {
  return typeof thing === 'number';
}

function isArray(thing) {
  return Object.prototype.toString.call(thing) === '[object Array]';
}

function isModule(thing) {
  return  thing && typeof thing === 'object' && thing.controller && thing.view;
}

function isTrusted(thing) {
  return thing.$trusted;
}

function isNativeDOM(el){
  return el.hasOwnProperty('nodeName') && el.hasOwnProperty('insertAdjacentHTML');
}

function windowStep(){
  window.requestAnimationFrame.$resolve();
}

function windowInit() {
  mockWindow.document.location = { hostname: 'localhost' };
  global.window = mockWindow;
  global.document = mockWindow.document;
  document.body = document.createElement('body');
  m.deps(mockWindow);
  windowStep();
}

function toVdomEl(node) {
  if(typeof node === 'undefined') { return; }

  var attrMap = {
    classname: 'className'
  };
  if (node.nodeValue) {
    return node.nodeValue;
  }
  var vdomEl = {};
  if(node.nodeName){
    vdomEl.tag = node.nodeName.toLowerCase();
  }
  if(node.attributes){
    vdomEl.attrs = node.attributes.reduce(function(attrs, attribute) {
      attrs[attrMap[attribute.name] || attribute.name] = attribute.value;
      return attrs;
    }, {});
  }
  vdomEl.children = [];
  vdomEl.children.nodes = [];
  if(node.childNodes){
    node.childNodes.filter(function(child){
      // By default mithril always has an empty `node: []` property for each child. This is
      // removed if any text/number items get added. Eg; you never see this;
      // ['text', nodes: []]
      // But you *do* see this;
      // [nodes: []]
      if(child.nodeValue){
        if(vdomEl.children.nodes && vdomEl.children.nodes.length === 0){
          delete vdomEl.children.nodes;
        }
        vdomEl.children.push(child.nodeValue);
      } else {
        if(typeof vdomEl.children.nodes === 'undefined'){
          vdomEl.children.nodes = [];
        }
        vdomEl.children.nodes.push(toVdomEl(child));
      }
    });
  }
  return vdomEl;
}

// Description of traditional DOM object tree. As generated by m.route('/')
var language = cssauron({
  tag: function(node){
    if(node.nodeName) {
      return node.nodeName.toLowerCase();
    } else {
      return '';
    }
  },
  contents: function(node) {
    if(!node.childNodes){
      return '';
    }
    var nodesWithText = node.childNodes.filter(function(child){
      if(child.nodeValue){
        return child.nodeValue;
      }
    });
    if(nodesWithText.length){
      // Concatenante all the nodeValues in an element together.
      // TODO: Is that right?? Is this how most HTML parsers would try to match for
      // element content??
      return nodesWithText.map(function(nWT){
        return nWT.nodeValue;
      }).join(' ');
    } else {
      return '';
    }
  },
  id: function(node) {
    return node.id;
  },
  class: function(node) {
    if (node.className){
      return node.className;
    }
    return '';
  },
  parent: 'parentNode',
  children: function(node) {
    if(node.childNodes[0].nodeValue){
      return '';
    } else {
      return node.childNodes;
    }
  },
  attr: function(node, attr) {
    if (node[attr]) {
      return node[attr];
    }
    return '';
  }
});

function join(arrays) {
  return arrays.reduce(function(result, array) {
    return result.concat(array);
  }, []);
}

function scan(render) {
  var calledWithNativeDOM = isNativeDOM(render);
  var api = {};

  function draw(render, rerender){
    var dom;

    if(calledWithNativeDOM){
      // When `render` has already been rendered into native DOM syntax. Eg. from a call to
      // `m.route('/page')` or `m.mount(document.body, module)`.
      dom = render;
    } else {
      var renderable = render();
      if(isModule(renderable)) {
        if(rerender){
          // If you just call `m.component()` again then the state gets reset
          m.redraw(true);
        } else {
          // When `render` has a mithril module syntax
          m.mount(document.body, renderable);
        }
      } else {
        // When `render` is already the result of some `m('div'...)` calls
        // Needs to be a function, so it can be redrawn just be calling `redraw()` again
        m.render(document.body, render());
      }
      dom = document.body;
    }
    api.rootElement = dom;
    // For backwards compatibility.
    // TODO: Doesn't receive the results of autorendering.
    api.rootEl = toVdomEl(dom.childNodes[0]);
  }

  draw(render);

  function find(selectorString, el, returnAsNativeDOM) {
    return select(language(selectorString))(el).map(function(el){
      // Return elements in the same syntax that they were provided. Provides backwards
      // comaptibility with older versions of mithril-query.
      if(!calledWithNativeDOM && !returnAsNativeDOM){
        el = toVdomEl(el);
      }
      return el;
    });
  }

  function select(matchesSelector) {
    return function matches(el, treePath) {
      treePath = treePath || '';
      if (isArray(el)) {
        return join(el.filter(identity).map(function(childEl, index) {
          return matches(childEl, treePath + PD + (childEl.key || index));
        }));
      }
      var foundEls = [];
      if (!el) {
        return foundEls;
      }
      if (matchesSelector(el)) {
        foundEls.push(el);
      }
      if (!el.childNodes || isString(el.childNodes)) {
        return foundEls;
      }
      el.childNodes.filter(identity).forEach(function(child) {
        // ignore text and number nodes
        if ((typeof child !== 'string') && (typeof child !== 'number')) {
          child.parentNode = el;
        }
      });
      return foundEls.concat(matches(el.childNodes, treePath));
    };
  }

  function first(selector, returnAsNativeDOM) {
    var el = find(selector, api.rootElement, returnAsNativeDOM)[0];
    if (!el) {
      throw new Error('No element matches ' + selector);
    }
    return el;
  }

  function has(selector) {
    return find(selector, api.rootElement).length > 0;
  }

  function contains(value, el) {
    if (!el) {
      return false;
    }
    if (isString(el) || isTrusted(el)) {
      return el.indexOf(value) >= 0;
    }
    if (isString(el.nodeValue)) {
      return el.nodeValue.indexOf(value) >= 0;
    }
    if (isString(el.childNodes)) {
      return el.childNodes.indexOf(value) >= 0;
    }
    if (isNumber(el)) {
      return el === value;
    }
    if (isNumber(el.childNodes)) {
      return el.childNodes === value;
    }
    if (isArray(el)) {
      return el.some(function(child) {
        return contains(value, child);
      });
    }
    if (el.childNodes && el.childNodes.length) {
      return el.childNodes.some(function(child) {
        return contains(value, child);
      });
    }
    return false;
  }

  function shouldHaveAtLeast(minCount, selector) {
    var actualCount = find(selector, api.rootElement).length;
    if (actualCount < minCount) {
      throw new Error('Wrong count of elements that matches "' + selector +
            '"\n  expected: >=' + minCount + '\n  actual: ' + actualCount);
    }
  }

  function shouldHave(expectedCount, selector) {
    if (!selector) {
      return shouldHaveAtLeast(1, expectedCount);
    }
    var actualCount = find(selector, api.rootElement).length;
    if (actualCount !== expectedCount) {
      throw new Error('Wrong count of elements that matches "' + selector +
            '"\n  expected: ' + expectedCount + '\n  actual: ' + actualCount);
    }
  }

  function shouldNotHave(selector) {
    shouldHave(0, selector);
  }

  function shouldContain(string) {
    if (!contains(string, api.rootElement)) {
      throw new Error('Expected "' + string + '" not found!');
    }
  }

  function shouldNotContain(string) {
    if (contains(string, api.rootElement)) {
      throw new Error('Unexpected "' + string + '" found!');
    }
  }

  function setValue(selector, string, silent) {
    var node = first(selector, true);
    var event = {
      currentTarget: {value: string},
      target: {value: string}
    };
    node.oninput && node.oninput(event);
    node.onchange && node.onchange(event);
    node.onkeyup && node.onkeyup(event);
    silent || api.redraw();
  }

  // Given an event name like 'click', trigger the function of the same name but with
  // 'on' prepended. Therefore click() fires onclick().
  function trigger(eventName) {
    return function (selector, event, silent) {
      if(typeof event === 'undefined' || event === null){
        event = {};
      }
      var node = first(selector, true);
      node['on' + eventName](event);
      silent || api.redraw();
    };
  }

  function triggerKey(eventName) {
    var fire = trigger(eventName);
    return function keydown(selector, key, silent) {
      fire(selector, {
        keyCode: isString(key) ? code(key) : key
      }, silent);
    };
  }

  shouldHave.at = {
    least: shouldHaveAtLeast
  };

  api.redraw = function(){
    if(calledWithNativeDOM){
      m.redraw(true);
    } else {
      draw(render, true);
    }
  };

  api.ajaxStub = function(mockResponse) {
    var xhr = window.XMLHttpRequest.$instances.pop();
    // Note: if mockResponse is empty then Mithril fills the response with the request instead,
    // which can be useful to test for correct headers, HTTP methods, etc.
    if(mockResponse) {
      xhr.responseText = JSON.stringify(mockResponse);
    }
    xhr.onreadystatechange();
  };

  api.first = first;
  api.has = has;
  api.contains = function(value) {
    return contains(value, api.rootElement);
  };
  api.find = function(selector) {
    return find(selector, api.rootElement);
  };
  api.setValue = setValue;
  ['focus', 'click', 'blur', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'].map(function(eventName) {
    api[eventName] = trigger(eventName);
  });
  api.keydown = triggerKey('keydown');
  api.keypress = triggerKey('keypress');
  api.keyup = triggerKey('keyup');
  api.trigger = function(selector, eventName, event, silent) {
    trigger(eventName)(selector, event, silent);
  };
  api.should = {
    not: {
      have: shouldNotHave,
      contain: shouldNotContain,
    },
    have: shouldHave,
    contain: shouldContain
  };
  return api;
}

function init(viewOrModuleOrRootEl, scope, b, c, d, e, f, noWay) {
  // Reset the mock DOM
  windowInit();

  if(isNativeDOM(viewOrModuleOrRootEl)){ return scan(viewOrModuleOrRootEl); }

  if (noWay) {
    throw new Error('More than 6 args of a component? Seriously? Such bad style is not supported.');
  }
  var api = {};
  var vdom = function(){ return viewOrModuleOrRootEl; };
  var isViewFunction = typeof viewOrModuleOrRootEl === 'function';
  if (isViewFunction) {
    vdom = function(){
      return {
        // TODO: add in a, b, etc...
        controller: function(){ return scope; },
        view: viewOrModuleOrRootEl
      };
    };
  } else if (isModule(viewOrModuleOrRootEl) && scope) {
    // Assume this is a component
    vdom = function(){
      // TODO: add in a, b, etc...
      return m.component(viewOrModuleOrRootEl, scope);
    };
  }
  api = scan(vdom);
  api.onunload = function() {
    // Recommended method for triggering all onunload() callbacks
    m.mount(document.body, null);
  };
  return api;
}

windowInit();

module.exports = init;
